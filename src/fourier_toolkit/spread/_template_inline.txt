# This is a template file used by `_spread.py`.
# Dollar-enclosed variables are replaced at runtime.

import numba as nb
import numba.types as nbt
import numpy as np

nb_flags = dict(
    nopython=True,
    nogil=True,
    cache=True,
    forceobj=False,
    parallel=False,
    error_model="numpy",
    fastmath=True,
    locals={},
    boundscheck=False,
)

D = ${z_rank}
# integer types -----------------------
i_t = nbt.int64
# 32-bit floating types ---------------
f32_t = nbt.float32
c32_t = nbt.complex64
c32_2A_t = nbt.Array(c32_t, 2, "A")
c32_2C_t = nbt.Array(c32_t, 2, "C")
c32_dA_t = nbt.Array(c32_t, 1 + D, "A")
c32_dC_t = nbt.Array(c32_t, 1 + D, "C")
f32_1C_t = nbt.Array(f32_t, 1, "C")
f32_2A_t = nbt.Array(f32_t, 2, "A")
f32_2C_t = nbt.Array(f32_t, 2, "C")
f32_dA_t = nbt.Array(f32_t, 1 + D, "A")
f32_dC_t = nbt.Array(f32_t, 1 + D, "C")
# 64-bit floating types ---------------
f64_t = nbt.float64
c64_t = nbt.complex128
c64_2A_t = nbt.Array(c64_t, 2, "A")
c64_2C_t = nbt.Array(c64_t, 2, "C")
c64_dA_t = nbt.Array(c64_t, 1 + D, "A")
c64_dC_t = nbt.Array(c64_t, 1 + D, "C")
f64_1C_t = nbt.Array(f64_t, 1, "C")
f64_2A_t = nbt.Array(f64_t, 2, "A")
f64_2C_t = nbt.Array(f64_t, 2, "C")
f64_dA_t = nbt.Array(f64_t, 1 + D, "A")
f64_dC_t = nbt.Array(f64_t, 1 + D, "C")
# lattice types -----------------------
l32_t = nbt.UniTuple(f32_1C_t, D)
l64_t = nbt.UniTuple(f64_1C_t, D)
# kernel types ------------------------
k32_t = nbt.UniTuple(nbt.FunctionType(f32_t(f32_t)), D)
k64_t = nbt.UniTuple(nbt.FunctionType(f64_t(f64_t)), D)
# PPoly fields ------------------------
ppoly_sym = ${ppoly_sym}  # symmetric kernel
ppoly_B = ${ppoly_bin_count}  # number of piecewise segments
ppoly_N = ${ppoly_order}  # polynomial order
ppoly_pitch_rcp = ${ppoly_pitch_rcp}
ppoly_support = ${ppoly_support}
ppoly_weight = (  # (B, N+1) polynomial coefficients in (aN,...,a0) order
${ppoly_weight}
)

@nb.jit(
    [
        f32_t(f32_t, nbt.UniTuple(f32_t, ppoly_N + 1)),
        f64_t(f64_t, nbt.UniTuple(f64_t, ppoly_N + 1)),
    ],
    **nb_flags,
    inline="always",
)
def horner(x, a):
    # Evaluate via Horner's rule
    #     f(x) = \sum_{n=0...N} a_n x**n
    #
    # Coefficients provided in order (aN,...,a0)
    y = a[0]
    for n in range(1, ppoly_N + 1):
        y *= x
        y += a[n]
    return y


@nb.jit(
    [
        f32_t(f32_t),
        f64_t(f64_t),
    ],
    **nb_flags,
    inline="always",
)
def _phi(x):
    if ppoly_sym:
        idx = min(int(abs(x) * ppoly_pitch_rcp), ppoly_B - 1)
        y = horner(abs(x), ppoly_weight[idx])
    else:
        idx = min(int((x + ppoly_support) * ppoly_pitch_rcp), ppoly_B - 1)
        y = horner(x, ppoly_weight[idx])
    return y


@nb.jit(
    [
        nbt.UniTuple(i_t, 2)(f32_t, f32_t, f32_1C_t),
        nbt.UniTuple(i_t, 2)(f64_t, f64_t, f64_1C_t),
    ],
    **nb_flags,
    inline="always",
)
def find_bounds(x, s, z):
    # Parameters
    #     x: float
    #     s: float > 0
    #     z: (N,) monotonically increasing
    # Returns
    #     a, b: ints satisfying
    #       x - s <= z[a] <= z[b] <= x + s
    N = len(z)

    a, lhs = 0, x - s
    while z[a] < lhs:
        a += 1

    b, rhs = N - 1, x + s
    while z[b] > rhs:
        b -= 1

    a, b = min(a, b), max(a, b)
    return a, b


@nb.jit(
    [
        f32_dC_t(f32_2C_t, f32_2A_t, l32_t, k32_t, f32_1C_t),
        c32_dC_t(f32_2C_t, c32_2A_t, l32_t, k32_t, f32_1C_t),
        f64_dC_t(f64_2C_t, f64_2A_t, l64_t, k64_t, f64_1C_t),
        c64_dC_t(f64_2C_t, c64_2A_t, l64_t, k64_t, f64_1C_t),
    ],
    **nb_flags,
)
def spread(x, w, z, phi, a):
    # Efficient sampling of
    #     g(z) = sum_{m} w_m \psi(z - x_m)
    #     \psi(x) = \phi(a x)
    #     \phi: [-1, 1] -> \bR
    #
    # Parameters
    #     x (Mq, D) offsets x_m
    #     w (Ns, Mq) [stacked] weights w_m
    #     z ((S1,),...,(SD,)) lattice points
    #     phi (D,) kernels \phi [unused inside body]
    #     a (D,) kernel scales `a`
    # Returns
    #     g (Ns, S1,...,SD) [stacked] samples of g(x)
    Mq = x.shape[0]
    Ns = w.shape[0]
    S = (${z_shape},)
    axes = (D, *${range_D})

    w = np.ascontiguousarray(w.T)  # (Mq, Ns)
    g = np.zeros((*S, Ns), dtype=w.dtype)  # (S1,...,SD, Ns)
    z_lb = np.empty(D, dtype=i_t)
    z_ub = np.empty(D, dtype=i_t)
    psi_v = np.zeros((D, max(S)), dtype=x.dtype)  # \psi values
    for m in range(Mq):
        for d in range(D):
            s = 1 / a[d]
            z_lb[d], z_ub[d] = find_bounds(x[m, d], s, z[d])
        support = (${support},)

        # compute (axial) kernel weights
        for d in range(D):
            for offset in range(support[d]):
                idx = z_lb[d] + offset
                psi_v[d, offset] = _phi(a[d] * (z[d][idx] - x[m, d]))

        for offset in np.ndindex(support):
            # compute (total) kernel weight
            k = 1
            for d in range(D):
                k *= psi_v[d, offset[d]]

            # spread onto grid
            idx = (${idx},)
            for ns in range(Ns):
                g[*idx, ns] += k * w[m, ns]

    g = np.ascontiguousarray(g.transpose(axes))  # (Ns, S1,...,SD)
    return g


@nb.jit(
    [
        f32_2C_t(f32_2C_t, f32_dA_t, l32_t, k32_t, f32_1C_t),
        c32_2C_t(f32_2C_t, c32_dA_t, l32_t, k32_t, f32_1C_t),
        f64_2C_t(f64_2C_t, f64_dA_t, l64_t, k64_t, f64_1C_t),
        c64_2C_t(f64_2C_t, c64_dA_t, l64_t, k64_t, f64_1C_t),
    ],
    **nb_flags,
)
def interpolate(x, g, z, phi, a):
    # Efficient evaluation of
    #     w_m = \sum_{n} g_n \psi(z_n - x_m)
    #     \psi(x) = \phi(a x)
    #     \phi: [-1, 1] -> \bR
    #
    # Parameters
    #     x (Mq, D) offsets x_m
    #     g (Ns, S1,...,SD) [stacked] samples g_n
    #     z ((S1,),...,(SD,)) lattice points
    #     phi (D,) kernels \phi [unused inside body]
    #     a (D,) kernel scales `a`
    # Returns
    #     w (Ns, Mq) [stacked] weights w_m
    Mq = x.shape[0]
    Ns = g.shape[0]
    S = (${z_shape},)
    axes = (*${range_Dp1}, 0)

    g = np.ascontiguousarray(g.transpose(axes))  # (S1,...,SD, Ns)
    w = np.zeros((Mq, Ns), dtype=g.dtype)  # (Mq, Ns)
    z_lb = np.empty(D, dtype=i_t)
    z_ub = np.empty(D, dtype=i_t)
    psi_v = np.zeros((D, max(S)), dtype=x.dtype)  # \psi values
    for m in range(Mq):
        for d in range(D):
            s = 1 / a[d]
            z_lb[d], z_ub[d] = find_bounds(x[m, d], s, z[d])
        support = (${support},)

        # compute (axial) kernel weights
        for d in range(D):
            for offset in range(support[d]):
                idx = z_lb[d] + offset
                psi_v[d, offset] = _phi(a[d] * (z[d][idx] - x[m, d]))

        for offset in np.ndindex(support):
            # compute (total) kernel weight
            k = 1
            for d in range(D):
                k *= psi_v[d, offset[d]]

            # spread onto support point
            idx = (${idx},)
            for ns in range(Ns):
                w[m, ns] += k * g[*idx, ns]

    w = np.ascontiguousarray(w.T)  # (Ns, Mq)
    return w
